// runner script, to create

/**
 * a simple script runner, to test the bundler and API.
 * for a simple target method, we just call the "nonce" method of the account itself.
 */

import { BigNumber, getDefaultProvider, Signer, Wallet } from "ethers";
import { JsonRpcProvider } from "@ethersproject/providers";
import {
    GuardianAccountDeployer__factory,
    GuardianAccount,
    GuardianAccount__factory,
} from "@account-abstraction/contracts";
import { formatEther, keccak256, parseEther } from "ethers/lib/utils";
import { erc4337RuntimeVersion } from "@account-abstraction/utils";
import { ethers } from "ethers";

import {
    DeterministicDeployer,
    HttpRpcClient,
    GuardianAccountAPI,
} from "@account-abstraction/sdk";

const ENTRY_POINT = "0x2DF1592238420ecFe7f2431360e224707e77fA0E";
const bundlerUrl = "http://localhost:3000/rpc";
const network = "http://localhost:8545";

export class Accounts {
    bundlerProvider!: HttpRpcClient;
    accountApi!: GuardianAccountAPI;
    guardianAccount!: GuardianAccount;

    /**
     *
     * @param provider - a provider for initialization. This account is used to fund the created account contract, but it is not the account or its owner.
     * @param bundlerUrl - a URL to a running bundler. must point to the same network the provider is.
     * @param accountOwner - the wallet signer account. used only as signer (not as transaction sender)
     * @param entryPointAddress - the entrypoint address to use.
     * @param index - unique salt, to allow multiple accounts with the same owner
     */
    constructor(readonly accountOwner: Signer, readonly index = 0) {}

    async getAddress(): Promise<string> {
        return await this.accountApi.getCounterFactualAddress();
    }

    async getAccountInfo(address: string) {
        const provider = getDefaultProvider(network) as JsonRpcProvider;
        const accountConstract = new ethers.Contract(
            address,
            GuardianAccount__factory.abi,
            provider,
        );

        const account = await accountConstract.benefici();
        console.log(account);
    }

    async init(): Promise<this> {
        const provider = getDefaultProvider(network) as JsonRpcProvider;
        let deploymentSigner: Signer = provider.getSigner();
        const index = Date.now();

        const net = await provider.getNetwork();
        const chainId = net.chainId;
        const dep = new DeterministicDeployer(provider);
        const accountDeployer = await dep.getDeterministicDeployAddress(
            GuardianAccountDeployer__factory.bytecode,
        );
        // const accountDeployer = await new SimpleAccountDeployer__factory(this.provider.getSigner()).deploy().then(d=>d.address)
        if (!(await dep.isContractDeployed(accountDeployer))) {
            if (deploymentSigner == null) {
                console.log(
                    `AccountDeployer not deployed at ${accountDeployer}. run with --deployDeployer`,
                );
                process.exit(1);
            }
            const dep1 = new DeterministicDeployer(
                deploymentSigner.provider as any,
            );
            await dep1.deterministicDeploy(
                GuardianAccountDeployer__factory.bytecode,
            );
        }
        this.bundlerProvider = new HttpRpcClient(
            bundlerUrl,
            ENTRY_POINT,
            chainId,
        );
        this.accountApi = new GuardianAccountAPI({
            provider: provider,
            entryPointAddress: ENTRY_POINT,
            factoryAddress: accountDeployer,
            owner: this.accountOwner,
            guardian: await this.accountOwner.getAddress(),
            index: index,
            overheads: {
                // perUserOp: 100000
            },
        });
        return this;
    }

    parseExpectedGas(e: Error): Error {
        // parse a custom error generated by the BundlerHelper, which gives a hint of how much payment is missing
        const match = e.message?.match(/paid (\d+) expected (\d+)/);
        if (match != null) {
            const paid = Math.floor(parseInt(match[1]) / 1e9);
            const expected = Math.floor(parseInt(match[2]) / 1e9);
            return new Error(
                `Error: Paid ${paid}, expected ${expected} . Paid ${Math.floor(
                    (paid / expected) * 100,
                )}%, missing ${expected - paid} `,
            );
        }
        return e;
    }

    async createSignedUserOp(target: string, data: string): Promise<void> {
        console.log(this.accountApi);

        let nData = await this.accountApi._getAccountContract();

        const userOp = await this.accountApi.createSignedUserOp({
            target: target,
            data: nData.interface.encodeFunctionData("getDeposit"),
        });
        try {
            const userOpHash = await this.bundlerProvider.sendUserOpToBundler(
                userOp,
            );
            const txid = await this.accountApi.getUserOpReceipt(userOpHash);
            console.log("reqId", userOpHash, "txid=", txid);
        } catch (e: any) {
            throw this.parseExpectedGas(e);
        }
    }

    async createRecovery(
        target: string,
        beneficiary: string,
        dday: number,
    ): Promise<void> {
        console.log(this.accountApi);

        let nData = await this.accountApi._getAccountContract();

        const userOp = await this.accountApi.createSignedUserOp({
            target: target,
            data: nData.interface.encodeFunctionData("createRecovery", [
                beneficiary,
                dday,
            ]),
        });
        try {
            const userOpHash = await this.bundlerProvider.sendUserOpToBundler(
                userOp,
            );
            const txid = await this.accountApi.getUserOpReceipt(userOpHash);
            console.log("reqId", userOpHash, "txid=", txid);
        } catch (e: any) {
            throw this.parseExpectedGas(e);
        }
    }

    async fundAccount(signer: Signer, addr: string): Promise<void> {
        const requiredBalance = parseEther("0.5");
        console.log("funding account to", requiredBalance);
        await signer.sendTransaction({
            to: addr,
            value: requiredBalance,
        });
    }
}
